import { NextRequest, NextResponse } from 'next/server';
import { binanceClient } from '@/lib/trading/binance';
import { ZGComputeClient } from '@/lib/0g/compute';

const zgCompute = new ZGComputeClient();

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { action, alpacaId, signal, symbol, symbols } = body;

    switch (action) {
      case 'getMarketData':
        const marketData = await binanceClient.getMarketData(symbol);
        return NextResponse.json({
          success: true,
          marketData,
          timestamp: Date.now()
        });

      case 'getMultipleMarketData':
        const multipleData = await binanceClient.getMultipleMarketData(symbols);
        return NextResponse.json({
          success: true,
          marketData: multipleData,
          count: multipleData.length
        });

      case 'executeTradeSignal':
        // Execute the trade signal
        const orderResult = await binanceClient.executeTradeSignal(signal, alpacaId);
        
        // Create trade record
        const tradeRecord = await binanceClient.createTradeRecord(orderResult, alpacaId);
        
        return NextResponse.json({
          success: true,
          order: orderResult,
          tradeRecord,
          message: `${signal.action} order executed for Alpaca ${alpacaId}`
        });

      case 'generateTradingSignal':
        // Use 0G Compute to generate trading signal
        const { marketData: currentMarket, alpacaContext } = body;
        
        await zgCompute.initialize();
        const strategy = await zgCompute.generateTradingStrategy(
          `Generate a trading signal based on current market data: ${JSON.stringify(currentMarket)}`,
          alpacaContext
        );
        
        // Parse strategy to create actual trading signal (simplified)
        const tradingSignal = {
          action: strategy.result.includes("BUY") ? "BUY" : 
                 strategy.result.includes("SELL") ? "SELL" : "HOLD",
          symbol: currentMarket.symbol || "BTCUSDT",
          quantity: 0.001,
          price: parseFloat(currentMarket.price || "0"),
          reason: "Generated by 0G AI Strategy",
          confidence: 0.8
        };

        return NextResponse.json({
          success: true,
          signal: tradingSignal,
          strategy: strategy.result,
          verified: strategy.verified
        });

      case 'getBalance':
        const balance = await binanceClient.getAccountBalance();
        return NextResponse.json({
          success: true,
          balance,
          message: "Account balance retrieved"
        });

      case 'autoTrading':
        // Start automated trading for an Alpaca
        const autoResult = await performAutoTrading(alpacaId, body.config);
        return NextResponse.json({
          success: true,
          ...autoResult
        });

      default:
        return NextResponse.json(
          { error: "Invalid trading action" }, 
          { status: 400 }
        );
    }
  } catch (error) {
    console.error("Trading API error:", error);
    return NextResponse.json(
      { 
        error: "Trading operation failed", 
        details: error instanceof Error ? error.message : "Unknown error"
      }, 
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const symbol = searchParams.get('symbol');
  const action = searchParams.get('action');

  try {
    if (action === 'marketData' && symbol) {
      const marketData = await binanceClient.getMarketData(symbol);
      return NextResponse.json({
        success: true,
        marketData
      });
    }

    if (action === 'balance') {
      const balance = await binanceClient.getAccountBalance();
      return NextResponse.json({
        success: true,
        balance
      });
    }

    return NextResponse.json({ 
      message: "Trading API",
      endpoints: {
        POST: "Execute trading operations",
        GET: "Get market data or balance (with ?action=marketData&symbol=BTCUSDT)",
        actions: [
          "getMarketData - Get single market data",
          "getMultipleMarketData - Get multiple market data",
          "executeTradeSignal - Execute a trading signal",
          "generateTradingSignal - Generate AI trading signals",
          "getBalance - Get account balance",
          "autoTrading - Start automated trading"
        ]
      },
      status: "Ready",
      demoMode: true
    });
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to process request" }, 
      { status: 500 }
    );
  }
}

async function performAutoTrading(alpacaId: string, config: any) {
  try {
    console.log(`ðŸ¤– Starting auto trading for Alpaca ${alpacaId}`);
    
    // Get current market data
    const marketData = await binanceClient.getMarketData(config.symbol || "BTCUSDT");
    
    // Initialize 0G Compute
    await zgCompute.initialize();
    
    // Generate trading strategy
    const strategy = await zgCompute.generateTradingStrategy(
      "Analyze current market conditions and provide a trading decision",
      config.alpacaContext
    );
    
    // Simplified signal extraction (in real implementation, parse strategy more intelligently)
    const shouldBuy = strategy.result.toLowerCase().includes("buy");
    const shouldSell = strategy.result.toLowerCase().includes("sell");
    
    if (shouldBuy || shouldSell) {
      const signal = {
        action: shouldBuy ? "BUY" : "SELL" as "BUY" | "SELL",
        symbol: config.symbol || "BTCUSDT",
        quantity: config.quantity || 0.001,
        price: parseFloat(marketData.price),
        reason: "Auto-generated by AI strategy"
      };
      
      const orderResult = await binanceClient.executeTradeSignal(signal, alpacaId);
      const tradeRecord = await binanceClient.createTradeRecord(orderResult, alpacaId);
      
      return {
        action: "trade_executed",
        signal,
        order: orderResult,
        tradeRecord,
        strategy: strategy.result
      };
    } else {
      return {
        action: "no_trade",
        reason: "AI strategy recommended HOLD",
        marketData,
        strategy: strategy.result
      };
    }
  } catch (error) {
    console.error("Auto trading failed:", error);
    return {
      action: "error",
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
}